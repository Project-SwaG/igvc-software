arduino/ArduinoInterface.cc:#include <boost/bind.hpp> 
arduino/ArduinoInterface.cc:boost::mutex ArduinoInterface::initmutex;
arduino/ArduinoInterface.cc:	boost::mutex::scoped_lock initlock(initmutex);
arduino/ArduinoInterface.cc:		asioserialport = new boost_asio::serial_port(my_io_service);
arduino/ArduinoInterface.cc:	asioserialport->set_option(boost_asio::serial_port_base::baud_rate(baud));
arduino/ArduinoInterface.cc:	asioserialport->set_option(boost_asio::serial_port_base::flow_control(boost_asio::serial_port_base::flow_control::none));
arduino/ArduinoInterface.cc:	asioserialport->set_option(boost_asio::serial_port_base::parity(boost_asio::serial_port_base::parity::none));
arduino/ArduinoInterface.cc:	asioserialport->set_option(boost_asio::serial_port_base::stop_bits(boost_asio::serial_port_base::stop_bits::one));
arduino/ArduinoInterface.cc:	void ArduinoInterface::handle_serial_read(const boost::system::error_code& ec, size_t len)
arduino/ArduinoInterface.cc:	//boost_asio::read(*asioserialport, boost_asio::buffer(buf, numBytes), boost_asio::transfer_all());
arduino/ArduinoInterface.cc:	boost_asio::async_read(*asioserialport, boost_asio::buffer(buf, numBytes), boost_asio::transfer_all(), boost::bind(&ArduinoInterface::handle_serial_read, this, boost_asio::placeholders::error, boost_asio::placeholders::bytes_transferred));
arduino/ArduinoInterface.cc:	boost_asio::write(*asioserialport, boost_asio::buffer(buf, numBytes), boost_asio::transfer_all());
arduino/ArduinoInterface.cc:	//boost_asio::async_write(*asioserialport, boost_asio::buffer(buf, numBytes), boost_asio::transfer_all(), boost::bind(&ArduinoInterface::writeDone, this, boost_asio::placeholders::error, boost_asio::placeholders::bytes_transferred));
arduino/ArduinoInterface.cc:		//boost_asio::read(*asioserialport, boost_asio::buffer(&b, 1), boost_asio::transfer_at_least(0));
arduino/ArduinoInterface.h:	#include <boost/asio.hpp>
arduino/ArduinoInterface.h:		namespace boost_asio = boost::asio;
arduino/ArduinoInterface.h:	namespace boost_asio = asio;
arduino/ArduinoInterface.h:#include <boost/array.hpp>
arduino/ArduinoInterface.h:#include <boost/thread.hpp>
arduino/ArduinoInterface.h:	boost_asio::io_service my_io_service;
arduino/ArduinoInterface.h:	boost_asio::serial_port* asioserialport;
arduino/ArduinoInterface.h:	static boost::mutex initmutex;
arduino/ArduinoInterface.h:	void handle_serial_read(const boost::system::error_code& ec, size_t len);
arduino/ArduinoInterface.h://	void writeDone(const boost::system::error_code& ec, const size_t s);
arduino/CMakeLists.txt:	boost_system-mt
arduino/CMakeLists.txt:	boost_thread-mt
extern/kdtree/test.cc:#include <boost/random.hpp>
extern/kdtree/test.cc:	boost::mt19937 rng;
extern/kdtree/test.cc:	boost::uniform_real<> unit(0.0, 1.0);
extern/kdtree/test.cc:	boost::variate_generator<boost::mt19937&, boost::uniform_real<> > die(rng, unit);
gps/CMakeLists.txt:	boost_thread
gps/CMakeLists.txt:	boost_system
gps/CMakeLists.txt:	boost_thread
gps/CMakeLists.txt:	boost_system
gps/IMU_Control.cc:	boost::mutex::scoped_lock lock(imu_off_mutex);
gps/IMU_Control.cc:			boost::mutex::scoped_lock lock(imu_off_mutex);
gps/IMU_Control.cc:			boost::mutex::scoped_lock lock(imu_off_mutex);
gps/IMU_Control.hpp:	boost::mutex imu_off_mutex;
gps/gps.cc:	iothread = boost::thread(boost::bind(&gps::gps_comm, this));
gps/gps.cc:	boost::mutex::scoped_lock lock(state_queue_mutex);
gps/gps.cc:		gps_port.set_option(boost::asio::serial_port_base::baud_rate(baud));
gps/gps.cc:		//gps_port.set_option(boost::asio::serial_port_base::flow_control(boost::asio::serial_port_base::flow_control::none));
gps/gps.cc:		gps_port.set_option(boost::asio::serial_port_base::parity(boost::asio::serial_port_base::parity::none));
gps/gps.cc:		gps_port.set_option(boost::asio::serial_port_base::stop_bits(boost::asio::serial_port_base::stop_bits::one));
gps/gps.cc:void gps::handle_serial_read_timer(const boost::system::error_code& ec)
gps/gps.cc:	boost::mutex::scoped_lock lock(state_queue_mutex);	
gps/gps.cc:void gps::handle_serial_read(const boost::system::error_code& ec, size_t len, boost::asio::deadline_timer& timeout)
gps/gps.cc:			boost::mutex::scoped_lock lock(state_queue_mutex);
gps/gps.cc:		boost::asio::deadline_timer timeout(io_service);
gps/gps.cc:		timeout.expires_from_now(boost::posix_time::milliseconds(2e3));
gps/gps.cc:			boost::asio::async_read_until(gps_port, comm_buffer, '\n', boost::bind(&gps::handle_serial_read, this, boost::asio::placeholders::error, boost::asio::placeholders::bytes_transferred, boost::ref(timeout)));
gps/gps.cc:			timeout.async_wait(boost::bind(&gps::handle_serial_read_timer, this, boost::asio::placeholders::error));
gps/gps.hpp:#include <boost/asio.hpp>
gps/gps.hpp:#include <boost/thread.hpp>
gps/gps.hpp:	boost::asio::streambuf comm_buffer;
gps/gps.hpp:	void handle_serial_read(const boost::system::error_code& ec, size_t len, boost::asio::deadline_timer& timeout);
gps/gps.hpp:	void handle_serial_read_timer(const boost::system::error_code& ec);
gps/gps.hpp:	boost::thread iothread;
gps/gps.hpp:	boost::asio::io_service io_service;
gps/gps.hpp:	boost::asio::serial_port gps_port;
gps/gps.hpp:	boost::mutex state_queue_mutex;
gps/gyro.cc:	iothread = boost::thread(boost::bind(&gyro::gyro_comm, this));
gps/gyro.cc:	boost::mutex::scoped_lock lock(state_queue_mutex);
gps/gyro.cc:		gyro_port.set_option(boost::asio::serial_port_base::baud_rate(baud));
gps/gyro.cc:		gyro_port.set_option(boost::asio::serial_port_base::flow_control(boost::asio::serial_port_base::flow_control::none));
gps/gyro.cc:		gyro_port.set_option(boost::asio::serial_port_base::parity(boost::asio::serial_port_base::parity::none));
gps/gyro.cc:		gyro_port.set_option(boost::asio::serial_port_base::stop_bits(boost::asio::serial_port_base::stop_bits::one));
gps/gyro.cc:void gyro::handle_serial_read_timer(const boost::system::error_code& ec)
gps/gyro.cc:	boost::mutex::scoped_lock lock(state_queue_mutex);	
gps/gyro.cc:void gyro::handle_serial_read(const boost::system::error_code& ec, size_t len, boost::asio::deadline_timer& timeout)
gps/gyro.cc:			boost::mutex::scoped_lock lock(state_queue_mutex);
gps/gyro.cc:		boost::asio::deadline_timer timeout(io_service);
gps/gyro.cc:		timeout.expires_from_now(boost::posix_time::milliseconds(2e3));
gps/gyro.cc:			boost::asio::async_read_until(gyro_port, comm_buffer, '\n', boost::bind(&gyro::handle_serial_read, this, boost::asio::placeholders::error, boost::asio::placeholders::bytes_transferred, boost::ref(timeout)));
gps/gyro.cc:			timeout.async_wait(boost::bind(&gyro::handle_serial_read_timer, this, boost::asio::placeholders::error));
gps/gyro.hpp:#include <boost/asio.hpp>
gps/gyro.hpp:#include <boost/thread.hpp>
gps/gyro.hpp:	boost::asio::streambuf comm_buffer;
gps/gyro.hpp:	void handle_serial_read(const boost::system::error_code& ec, size_t len, boost::asio::deadline_timer& timeout);
gps/gyro.hpp:	void handle_serial_read_timer(const boost::system::error_code& ec);
gps/gyro.hpp:	boost::thread iothread;
gps/gyro.hpp:	boost::asio::io_service io_service;
gps/gyro.hpp:	boost::asio::serial_port gyro_port;
gps/gyro.hpp:	boost::mutex state_queue_mutex;
gps/nmea.cc:#include <boost/lexical_cast.hpp>
gps/nmea.cc:#include <boost/algorithm/string.hpp>
gps/nmea.cc:	double raw = boost::lexical_cast<double>(val.c_str());
gps/nmea.cc:	double raw = boost::lexical_cast<double>(val.c_str());
gps/nmea.cc:	boost::algorithm::split(splitvec, line, boost::algorithm::is_any_of(","), boost::algorithm::token_compress_off);
gps/nmea.cc:		double speedKTS = boost::lexical_cast<double>(splitvec[7].c_str());
gps/nmea.cc:	state.courseoverground = boost::lexical_cast<double>(splitvec[8].c_str());
gps/nmea.cc:		double magvariation = boost::lexical_cast<double>(splitvec[10].c_str());
gps/nmea.cc:	boost::algorithm::split(splitvec, line, boost::algorithm::is_any_of(","), boost::algorithm::token_compress_off);
gps/nmea.cc:	state.num_sat = boost::lexical_cast<int>(numsat.c_str());
gps/nmea.cc:	boost::algorithm::split(splitvec, line, boost::algorithm::is_any_of(","), boost::algorithm::token_compress_off);
gps/nmea.cc:		state.rpy[0] = boost::lexical_cast<double>(splitvec[1]) / 10.0;
gps/nmea.cc:		state.rpy[1] = boost::lexical_cast<double>(splitvec[2]) / 10.0;
gps/nmea.cc:		state.rpy[2] = boost::lexical_cast<double>(splitvec[3]) / 10.0;
gps/nmea.cc:		state.balloffset = boost::lexical_cast<double>(splitvec[4]) / 100.0;
gps/nmea.cc:		state.yawrate = boost::lexical_cast<double>(splitvec[5]) / 100.0;
lidar/CMakeLists.txt:	boost_thread-mt
lidar/CMakeLists.txt:	boost_thread-mt
lidar/NAV200.hpp:#include "boost/tuple/tuple.hpp"
lidar/NAV200.hpp:#include "boost/foreach.hpp"
lidar/datadump.cc:#include "boost/tuple/tuple.hpp"
lidar/datadump.cc:#include "boost/tuple/tuple_io.hpp"
lidar/datadump.cc:#include "boost/foreach.hpp"
lidar/datadump.cc:typedef boost::tuple<float,float> range;
lidar/find_linear_test.cc:#include "boost/tuple/tuple.hpp"
lidar/find_linear_test.cc:#include "boost/foreach.hpp"
lidar/find_linear_test.cc:typedef boost::tuple<int,int> range;
lidar/find_linear_test.cc:	std::list< boost::tuple<int,int> > lines;
lidar/find_linear_test.cc:			lines.push_back( boost::tuple<size_t,size_t>(start, stop) );
lidar/find_linear_test.cc:			lines.push_back( boost::tuple<size_t,size_t>(start, stop) );
lidar/lidarProc.cc:#include "boost/foreach.hpp"
lidar/lidarProc.cc:bool findLinearRuns(const float* theta, const float* radius, const size_t len, const double zero_tol, std::deque< boost::tuple<size_t,size_t> >& lines)
lidar/lidarProc.cc:			lines.push_back( boost::tuple<size_t,size_t>(start, stop) );
lidar/lidarProc.cc:			lines.push_back( boost::tuple<size_t,size_t>(start, stop) );
lidar/lidarProc.cc:bool findLinearRuns(const float* theta, const float* radius, const size_t len, const double zero_tol, std::deque< boost::tuple<size_t,size_t> >& lines)
lidar/lidarProc.cc:			boost::tuple<size_t, size_t> run(start, stop);
lidar/lidarProc.cc:void getLongestRun(const float* x, const float* y, const std::deque< boost::tuple<size_t,size_t> >& lines, boost::tuple<size_t,size_t>& longest)
lidar/lidarProc.cc:	bool collectNearRuns(const float* theta, const float* radius, const size_t len, const double distance, std::deque< boost::tuple<size_t,size_t> >& lines, std::deque< boost::tuple<size_t,size_t> >& grown_lines)
lidar/lidarProc.cc:		const boost::tuple<size_t,size_t>& pt = lines[i];
lidar/lidarProc.cc:		const boost::tuple<size_t,size_t>& next_pt = lines[i+1];
lidar/lidarProc.cc:				boost::tuple<size_t,size_t> seg;
lidar/lidarProc.hpp:#include <boost/tuple/tuple.hpp>
lidar/lidarProc.hpp:	bool findLinearRuns(const float* theta, const float* radius, const size_t len, const double zero_tol, std::deque< boost::tuple<size_t,size_t> >& lines);
lidar/lidarProc.hpp:	bool collectNearRuns(const float* theta, const float* radius, const size_t len, const double distance, std::deque< boost::tuple<size_t,size_t> >& lines, std::deque< boost::tuple<size_t,size_t> >& grown_lines);
lidar/lidarProc.hpp:	void getLongestRun(const float* theta, const float* radius, const std::deque< boost::tuple<size_t,size_t> >& lines, boost::tuple<size_t,size_t>& longest);
lidar/lidartestgui.cc:#include <boost/thread.hpp>
lidar/lidartestgui.cc:boost::mutex winMutex;
lidar/lidartestgui.cc:boost::mutex rawImageMutex;
lidar/lidartestgui.cc:boost::mutex runavgMutex;
lidar/lidartestgui.cc:boost::mutex rmisoLidarMutex;
lidar/lidartestgui.cc:boost::mutex morphLidarMutex;
lidar/lidartestgui.cc:boost::mutex linesLidarMutex;
lidar/lidartestgui.cc:boost::mutex grownlinesLidarMutex;
lidar/lidartestgui.cc:boost::mutex isclearLidarMutex;
lidar/lidartestgui.cc:boost::mutex ispathclearLidarMutex;
lidar/lidartestgui.cc:	boost::mutex::scoped_lock lock(winMutex);
lidar/lidartestgui.cc:				boost::mutex::scoped_lock lock(rawImageMutex);
lidar/lidartestgui.cc:				boost::mutex::scoped_lock lock(runavgMutex);
lidar/lidartestgui.cc:				boost::mutex::scoped_lock lock(rmisoLidarMutex);
lidar/lidartestgui.cc:				boost::mutex::scoped_lock lock(morphLidarMutex);
lidar/lidartestgui.cc:				boost::mutex::scoped_lock lock(linesLidarMutex);
lidar/lidartestgui.cc:				boost::mutex::scoped_lock lock(grownlinesLidarMutex);
lidar/lidartestgui.cc:				boost::mutex::scoped_lock lock(isclearLidarMutex);
lidar/lidartestgui.cc:				boost::mutex::scoped_lock lock(ispathclearLidarMutex);
lidar/lidartestgui.cc:			boost::mutex::scoped_lock lock(linesLidarMutex);
lidar/lidartestgui.cc:			boost::mutex::scoped_lock lock(grownlinesLidarMutex);
lidar/lidartestgui.cc:			boost::mutex::scoped_lock lock(rawImageMutex);
lidar/lidartestgui.cc:			std::deque< boost::tuple<size_t,size_t> > lines;
lidar/lidartestgui.cc:			boost::tuple<size_t,size_t> pt;
lidar/lidartestgui.cc:				boost::mutex::scoped_lock lock(linesLidarMutex);
lidar/lidartestgui.cc:			std::deque< boost::tuple<size_t,size_t> > grow_lines;
lidar/lidartestgui.cc:				boost::mutex::scoped_lock lock(grownlinesLidarMutex);
lidar/lidartestgui.cc:			std::deque< boost::tuple<size_t,size_t> > lines;
lidar/lidartestgui.cc:			boost::tuple<size_t,size_t> pt;
lidar/lidartestgui.cc:				boost::mutex::scoped_lock lock(linesLidarMutex);
lidar/test.cc:#include "boost/tuple/tuple.hpp"
lidar/test.cc:#include "boost/tuple/tuple_io.hpp"
lidar/test.cc:#include "boost/foreach.hpp"
lidar/test.cc:typedef boost::tuple<float,float> range;
lidar/test.cc:		std::deque< boost::tuple<size_t,size_t> > lines;
lidar/test.cc:		boost::tuple<size_t,size_t> longest;
lidar/testpathclear.cc:#include <boost/thread.hpp>
roxi/2009_candiii_dependencies.txt:boost
roxi/CMakeLists.txt:	boost_thread-mt
roxi/CMakeLists.txt:	boost_thread-mt
roxi/Robot.cpp:		boost::mutex::scoped_lock lock(velmutex);
roxi/Robot.cpp:	vel_update_thread = new boost::thread(&Robot::update_vel_func, this);
roxi/Robot.cpp:	lidar_update_thread = new boost::thread(&Robot::update_lidar_func, this);
roxi/Robot.cpp:	gps_update_thread = new boost::thread(&Robot::update_gps_func, this);
roxi/Robot.cpp:			boost::mutex::scoped_lock lock(velmutex);
roxi/Robot.cpp:			boost::mutex::scoped_lock lock(velmutex);
roxi/Robot.cpp:		boost::mutex::scoped_lock lock(velmutex);
roxi/Robot.cpp:			boost::mutex::scoped_lock lock(lidarmutex);
roxi/Robot.cpp:	      boost::mutex::scoped_lock lock(gpsmutex);
roxi/Robot.h:	boost::mutex velmutex;
roxi/Robot.h:	boost::thread* vel_update_thread;
roxi/Robot.h:	boost::mutex lidarmutex;
roxi/Robot.h:	boost::mutex gpsmutex;
roxi/Robot.h:	boost::thread* lidar_update_thread;
roxi/Robot.h:	boost::thread* gps_update_thread;
roxi/Robot.h:	//std::deque< boost::tuple<float,float> > lidar_linear_regions;
roxi/Robot.h:	//boost::tuple<float,float> longest_linear_region;
roxi/Robot.h:	//boost::tuple<float,float> coord[NAV200::Num_Points];
roxi/RobotPosition/CMakeLists.txt:	boost_system
roxi/RobotPosition/CMakeLists.txt:	boost_thread
roxi/install_dependencies:echo "boost ==================================================================="
roxi/install_dependencies:sudo apt-get --yes install libboost1.35-dev	#ubuntu 8.10
roxi/install_dependencies:#sudo apt-get --yes install libboost-dev		#ubuntu 8.04
roxi/vision/DCam.h:#include <boost/utility.hpp>
roxi/vision/DCam.h:class DCam: public Base, boost::noncopyable
simple_gps_lidar_drive/gps_imu_main.cc://#include <boost/asio.hpp>
simple_gps_lidar_drive/gps_imu_main.cc:void handle_timer(const boost::system::error_code& ec)
simple_gps_lidar_drive/gps_imu_main.cc:	boost::asio::io_service io_service;
simple_gps_lidar_drive/gps_imu_main.cc:			boost::asio::deadline_timer timeout(io_service);
simple_gps_lidar_drive/gps_imu_main.cc:			timeout.expires_from_now(boost::posix_time::milliseconds(2e3));
simple_gps_lidar_drive/gps_imu_main.cc:			timeout.async_wait(boost::bind(handle_timer, boost::asio::placeholders::error));
